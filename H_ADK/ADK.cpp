/****************************************************************ADK for H atom_141001//170623 Time evolution*******************************************************************/#include <stdio.h>#include <stdlib.h>#include <math.h>#include <time.h>#define SERIES 100000const double pi =acos(-1.0) ;const double kB=1.3806504*pow(10.0,-23.0) ; // Boltzmann constantconst double h=6.62606896*pow(10.0,-34.0) ; // Planck constant in Jï½¥secconst double hbar=h/2.0/pi ; // Dirac constant difined as hbar=h/piconst double c=299792458.0 ; // velocity of light in m/secconst double epsilon=8.854187817*pow(10.0,-12.0) ; // permittivity of vacuum const double me = 9.10938215*pow(10.0,-31.0) ; // kgconst double e = 1.602176487 * pow(10.0,-19.0) ; // Cconst double a0 = 5.29177249 * pow(10.0,-11.0) ; // Bohr Radius [m] http://goldbook.iupac.org/html/A/A00504.htmlconst double Eau = e  / a0 / a0 / 4.0 / pi / epsilon ;// [V/m]const double Eh = me * e * e * e * e / (4.0 * pi * epsilon * hbar) / (4.0 * pi * epsilon * hbar) ;// hartree  [J]const double Tau = hbar/Eh ; // sec double E(double t , double intensity , double FWHM , double lambda  ); //laser pulse double Rate(double intensity , double FWHM,double lambda, double t) ;double Simpson(double intensity , double FWHM,double lambda,double ta,double tb, int N);/***************************************************************//**Cl coefficients**/double IP = 13.6 ; //in eV unit// double a = 6.0 ; // barrier surpression   X.M.Tong and C.D.Lin, J. Phys. B: At. Mol. Opt. Phys. 38, 2593 (2005)double Zc = 1.0 ; /***************************************************************/double Ip = IP * 0.03674933 ; //in Hartree unitdouble k = sqrt(2.0*Ip);int main(){/***************************************************************/	double intensity = 1.0*pow(10.0,14.0) ; // W/cm^2	double FWHM = 10.0 * pow(10.0,-15.0)  / Tau ; // au.	double lambda = 800 * pow(10.0,-9.0) ; // nm/***************************************************************//***************************************************************/	double dt = 0.005 * pow(10.0,-15.0) / Tau; // au	int N = 50000 ; // number of segment in numerical integration/***************************************************************/	double tint = - 1.0* FWHM ; // time in atomic units 	double tfin =   1.0 * FWHM  ;	double Prob  ; // Population	int TotNum = int((tfin-tint)/dt) + 1 ;	int Num = 0;	FILE *fp1 , *fp2, *fp3;	fp1 = fopen("Population.txt","w") ;	fp2 = fopen("ElectricField.txt","w") ;	fp3 = fopen("IonizationRate.txt","w") ;		for(double t = tint ; t<= tfin ; t = t +dt)	{				Prob= 1.0 - exp(- Simpson(intensity , FWHM,lambda, tint , t , N)) ;		fprintf(fp1,"%f\t%f\n", t* Tau * pow(10.0,15.0) , Prob) ;		fprintf(fp2,"%f\t%f\n", t* Tau * pow(10.0,15.0) , E(t , intensity , FWHM ,lambda) ) ;		fprintf(fp3,"%f\t%f\n", t* Tau * pow(10.0,15.0) , Rate(intensity , FWHM, lambda, t)  ) ;		printf("%d / %d\n", Num,TotNum);		Num=Num+1;	}return 0;}// end of the main functiondouble E(double t , double intensity , double FWHM , double lambda  ) //laser pulse {	double freq = c/lambda * Tau ;	double envelope = exp(-2.0*log(2.0)*t*t/FWHM/FWHM) ; 	double E0 = sqrt( 2.0 * intensity * 10000.0 / epsilon / c ) / Eau ; // amplitude of 800 nm fundumental in a.u.	double ret = E0*envelope*cos(2.0*pi*freq*t)  ; //return in atomic unit	return ret;}// ADK ratedouble Rate(double intensity , double FWHM,double lambda,  double t) {    double W=0;    double F ;	double Fthr = 0.00001 ; // threshold	F = fabs(E(t,intensity,FWHM,lambda)) ;    if(Fthr<F)        W = 4.0 * k * k * k * k * k / F * exp( -2.0/3.0 * k * k * k / F ) ;//	W = 4.0 * k * k * k * k * k / F * exp( -2.0/3.0 * k * k * k / F ) * exp( -a*(Zc*Zc/Ip)*F/(k*k*k) ) ; 	return W ;}/************************************integral range[ta:tb]. Simpson************************************/double Simpson(double intensity , double FWHM,double lambda,  double ta,double tb, int N){	double Se=0.0 , So=0.0 , h ;		if(ta == tb)		return Rate(intensity,FWHM,lambda,tb);		else	{		h=(tb-ta)/double(N) ;		for(int i=1;i<=N/2-1;i++)		{			double tx=ta+h*double(2*i);			Se = Se+Rate(intensity,FWHM,lambda,tx);		}		for(int i=1; i<=N/2; i++)		{			double tx=ta+h*double(2*i-1);			So=So+Rate(intensity,FWHM,lambda,tx);		}		return (h/3.0)*(Rate(intensity,FWHM,lambda,ta)+2.0*Se+4.0*So+Rate(intensity,FWHM,lambda,tb));	}			}